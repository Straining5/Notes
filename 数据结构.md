# 矩阵的压缩存储

## 对称阵

对于如下矩阵：

![对称矩阵](https://img-blog.csdnimg.cn/20190106212216841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

以深灰色为对称轴，由于矩阵内数据对称，因此只需要将任意一边的数据存储起来即可。

需要存储的元素为：

![需要存储的元素](https://img-blog.csdnimg.cn/20190106212627226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

各个元素对应在一维数组中的位置示意图：￼

![位置示意图](https://img-blog.csdnimg.cn/20190106213715388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

### 矩阵坐标转换数组坐标

数组坐标 $k=$ 矩阵元素 $a_{ij}$ 上面的 $i-1$ 行的元素个数 $+$ 当前行前面的元素个数（注意矩阵从 $a_{11}$ 开始计数）

**前 i -1 行的元素个数**

等差数列求和，$a_1=1,a_n=i-1,n=i-1$ （每行的元素个数就是它的行序）

$S_n = \dfrac{(a_1+a_n)n}{2}=\dfrac{i(i-1)}{2}$

**当前行前面的元素个数**

$j-1$

因此，可以得到 $k=\dfrac{i(i-1)}{2}+j-1$

上面的公式存储的是下三角的元素。对于上三角的元素，由于 $a_{ij}=a_{ji}$，因此上三角的元素位置公式可以将上式中的 $i$ 与 $j$ 互换得到。即 $k_{上三角}=\dfrac{j(j-1)}{2}+i-1$

## 三角矩阵

采用和对称阵相同的存储方式存储。

## 稀疏矩阵

只存储非零元，非零元的个数以及矩阵的大小。非零元通过 `(行标, 列标, 值)` 的三元组存储。

### 三元组顺序表

```c
typedef struct {
  int i, j;
  int val;
} Triple;

typedef struct {
  Triple data[number]; //三元组数组
  int n, m;            //矩阵的行数和列数
  int num;             //非零元个数
} TSMatrix;
```

### 行逻辑链接的顺序表

三元组顺序表每次提取指定元素都要遍历整个数组，效率很低。因此提出了三元组顺序表的升级版——行逻辑链接的顺序表。

行逻辑链接的顺序表在三元组顺序表的基础上加入了一个用于记录矩阵中每行的首非零元在三元组数组中的位置的数组。

```c
typedef struct {
  Triple data[MAXSIZE + 1];
  int rpos[MAXRC + 1];
  int n, m;
  int num;
} RLSMatrix;
```

![矩阵](http://c.biancheng.net/uploads/allimg/190426/1P0415221-0.gif)

对于上面的矩阵，采用行逻辑链接的顺序表存储时，需要做两个工作：

1. 将矩阵中的非零元存储到三元组数组。

![三元组数组](http://c.biancheng.net/uploads/allimg/190426/1P0411224-1.gif)

2. 使用数组 rpos 记录矩阵中每行的首非零元在 data 中的位置。

![rpos 数组](http://c.biancheng.net/uploads/allimg/190426/1P0414334-2.gif)

这样，当我们提取元素时，就可利用 rpos 数组定位要访问的位置区间来提高效率。

```c
void display(RLSMatrix M)
{
  for (int i = 1; i <= M.m; ++i)
  {
    for (int j = 1; j <= M.n; ++j)
    {
      int flag = 0; //标记某位置是否为非零元
      if (i + 1 <= M.m) //如果不是最后一行
      {
        for (int k = M.rpos[i]; k < M.rpos[i + 1]; ++k) //通过 rpos 数组定位这一行在三元组中的位置
        {
          if (i == M.data[k].i && j == M.data[k].j) //如果在该位置有非零元
          {
            printf("%d ", M.data[k].val);
            flag = 1;
            break;
          }
        }
        if (flag == 0) //没有遇到非零元
        {
          printf("0 ");
        }
      }
      else //最后一行
      {
        for (int k = M.rpos[i]; k <= M.num; ++k) //定位
        {
          if (i == M.data[k].i && j == M.data[k].j) //遇到非零元
          {
            printf("%d ", M.data[k].e);
            flag = 1;
            break;
          }
        }
        if (flag == 0)
        {
          printf("0 ");
        }
      }
    }
    printf("\n"); //每行输出完输出一个换行
  }
}
```

> [行逻辑链接的顺序表](http://c.biancheng.net/view/3372.html)

### 十字链表法

为解决数组不便于插入或删除的问题，提出了十字链表法。

> [十字链表法详解](http://c.biancheng.net/view/3373.html)

# 稀疏矩阵的转置算法

转置：$a_{i,j}=a_{j,i}$

对于使用三元组顺序表或行逻辑链接的顺序表存储的矩阵，在转置时需要完成以下三步：

1. 将矩阵的行数 m 和列数 n 互换。
2. 将三元组表中每个元素的 i 和 j 互换。
3. 重新排列三元组表中的元素顺序。

**简单实现思路：不断遍历存储矩阵的三元组表，每次都从中取出 j 最小的那一个元素（如果有多个，则按照他们原来在三元组中的次序依次取出），互换 i 和 j，然后存储到一个新的三元组表中**

![矩阵转置的第一个过程](http://c.biancheng.net/uploads/allimg/190426/1P24161c-2.gif)

![矩阵转置的第二个过程](http://c.biancheng.net/uploads/allimg/190426/1P2416144-3.gif)

该算法的时间复杂度为 $O(n^2)$

> [稀疏矩阵的转置算法](http://c.biancheng.net/view/3374.html)

# 树

## 树的常用定理

度
: 一个结点含有的子结点的个数
: 二叉树中的度指的是出度

1. 所有结点的度数之和是边数的 2 倍（这里的度是指一般的度）
2. 树中的边数等于结点数减 1

## 二叉树

### 二叉树的遍历

> [二叉树先序遍历](http://c.biancheng.net/view/3388.html)

### 线索二叉树

```c
typedef enum {Link, Thread} PointerTag; //指示指针域存储的是孩子还是前驱后继的枚举

typedef struct BiThrNode {
    TElemType data; //数据域
    struct BiThrNode *lchild, *rchild; //左、右孩子指针域
    PointerTag Ltag, Rtag; //标志域
} BiThrNode, *BiThrTree;
```

#### 对二叉树进行线索化

```c
//中序对二叉树进行线索化
void InThreading(BiThrTree p) {
    static BiThrNode* pre = NULL; //上一次访问的结点，即前驱
    if (p) { //如果当前结点存在
        InThreading(p->lchild); //递归当前结点的左子树，一直到最左下
        //如果当前结点没有左孩子，写入前驱
        if (!p->lchild) {
            p->Ltag = Thread;
            p->lchild = pre;
        }
        //如果前驱没有右孩子，写入后继
        if (pre && !pre->rchild) {
            pre->Rtag = Thread;
            pre->rchild = p;
        }
        pre = p; //更新前驱
        InThreading(p->rchild); //递归右子树进行线索化
    }
}
```

> 在两条递归语句中间的语句相当于访问二叉树中的访问操作。如果把它放到两条递归语句前面，就变成前序线索二叉树。

#### 遍历线索二叉树

```c
//中序遍历线索二叉树
void InOrderThraverse_Thr(BiThrTree p) {
    while (p) {
        while (p->Ltag == Link) { //一直找左孩子，一直到最左下的结点
            p = p->lchild;
        }
        printf("%c ", p->data);  //操作结点数据
        //如果结点存储了后继，就直接访问后继
        while(p->Rtag == Thread && p->rchild != NULL) {
            p = p->rchild;
            printf("%c ", p->data);
        }
        //如果没有后继，说明有右孩子。则找其右子树中最左下的结点，也就是继续循环遍历
        p = p->rchild;
    }
}
```

> [线索二叉树](http://c.biancheng.net/view/vip_3391.html)

### 双向线索二叉树


> [双向线索二叉树](http://c.biancheng.net/view/vip_3393.html)

## 树

树与二叉树的区别：

1. 二叉树是有序树。
2. 树的度指树中最大的度。因此度为 2 的树不能是空树。而二叉树可以是空树。

### 树的孩子兄弟表示法

其实和二叉树的存储结构是一样的

```c
struct TreeNode {
  ElemType val;
  struct TreeNode *nextSon, *nextBro;
}
```

> [树的孩子兄弟表示法](http://c.biancheng.net/view/3396.html)

### 树转换为二叉树


### 森林

森林的遍历

每棵树做先根遍历

