# 矩阵的压缩存储

## 对称阵

对于如下矩阵：

![对称矩阵](https://img-blog.csdnimg.cn/20190106212216841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

以深灰色为对称轴，由于矩阵内数据对称，因此只需要将任意一边的数据存储起来即可。

需要存储的元素为：

![需要存储的元素](https://img-blog.csdnimg.cn/20190106212627226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

各个元素对应在一维数组中的位置示意图：

![位置示意图](https://img-blog.csdnimg.cn/20190106213715388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NXRUVORVlfSEU=,size_16,color_FFFFFF,t_70)

### 矩阵坐标转换数组坐标

数组下标 k 等于矩阵元素 $a_{ij}$ 上面的 i - 1 行的元素个数加上当前行前面的元素个数（注意矩阵从 $a_{11}$ 开始计数）

**前 i -1 行的元素个数**

等差数列求和，$a_1=1,a_n=i-1,n=i-1$ （每行的元素个数就是它的行序）

$S_n = \dfrac{(a_1+a_n)n}{2}=\dfrac{i(i-1)}{2}$

**当前行前面的元素个数**

$j-1$

因此，可以得到 $k=\dfrac{i(i-1)}{2}+j-1$

上面的公式存储的是下三角的元素。对于上三角的元素，由于 $a_{ij}=a_{ji}$，因此上三角的元素位置公式可以将上式中的 $i$ 与 $j$ 互换得到。即 $k_{上三角}=\dfrac{j(j-1)}{2}+i-1$

## 三角矩阵

采用和对称阵相同的存储方式存储。

## 稀疏矩阵

只存储非零元，非零元的个数以及矩阵的大小。非零元通过 `(行标, 列标, 值)` 的三元组存储。

### 三元组顺序表

```c
typedef struct {
  int i, j;
  int val;
} Triple;

typedef struct {
  Triple data[number]; //三元组数组
  int n, m;            //矩阵的行数和列数
  int num;             //非零元个数
} TSMatrix;
```

### 行逻辑链接的顺序表

三元组顺序表每次提取指定元素都要遍历整个数组，效率很低。因此提出了三元组顺序表的升级版——行逻辑链接的顺序表。

行逻辑链接的顺序表在三元组顺序表的基础上加入了一个用于记录矩阵中每行的首非零元在三元组数组中的位置的数组。

```c
typedef struct {
  Triple data[MAXSIZE + 1];
  int rpos[MAXRC + 1];
  int n, m;
  int num;
} RLSMatrix;
```

![矩阵](http://c.biancheng.net/uploads/allimg/190426/1P0415221-0.gif)

对于上面的矩阵，采用行逻辑链接的顺序表存储时，需要做两个工作：

1. 将矩阵中的非零元存储到三元组数组。

![三元组数组](http://c.biancheng.net/uploads/allimg/190426/1P0411224-1.gif)

2. 使用数组 rpos 记录矩阵中每行的首非零元在 data 中的位置。

![rpos 数组](http://c.biancheng.net/uploads/allimg/190426/1P0414334-2.gif)

这样，当我们提取元素时，就可利用 rpos 数组定位要访问的位置区间来提高效率。

```c
void display(RLSMatrix M) {
  for (int i = 1; i <= M.m; ++i) {
    for (int j = 1; j <= M.n; ++j) {
      int flag = 0; //标记某位置是否为非零元
      if (i + 1 <= M.m) //如果不是最后一行
      {
        for (int k = M.rpos[i]; k < M.rpos[i + 1]; ++k) //通过 rpos 数组定位这一行在三元组中的位置
        {
          if (i == M.data[k].i && j == M.data[k].j) //如果在该位置有非零元
          {
            printf("%d ", M.data[k].val);
            flag = 1;
            break;
          }
        }
        if (flag == 0) //没有遇到非零元
        {
          printf("0 ");
        }
      } else //最后一行
      {
        for (int k = M.rpos[i]; k <= M.num; ++k) //定位
        {
          if (i == M.data[k].i && j == M.data[k].j) //遇到非零元
          {
            printf("%d ", M.data[k].e);
            flag = 1;
            break;
          }
        }
        if (flag == 0) {
          printf("0 ");
        }
      }
    }
    printf("\n"); //每行输出完输出一个换行
  }
}
```

[行逻辑链接的顺序表](http://c.biancheng.net/view/3372.html)

### 十字链表法

为解决数组不便于插入或删除的问题，提出了十字链表法。

![十字链表示意图](http://c.biancheng.net/uploads/allimg/190426/1P2002442-0.gif)

如图，有一个行数组和一个列数组，数组中存的是该行（列）所有非零元的链表。

![十字链表的结点结构](http://c.biancheng.net/uploads/allimg/190426/1P2005c9-1.gif)

```cpp
class OLNode {
  int i, j;
  int val;
  OLNode *right, *down;
}
```

[十字链表法详解](http://c.biancheng.net/view/3373.html)

# 稀疏矩阵的转置算法

转置：$a_{ij}=a_{ji}$

对于使用三元组顺序表或行逻辑链接的顺序表存储的矩阵，在转置时需要完成以下三步：

1. 将矩阵的行数 m 和列数 n 互换。
2. 将三元组表中每个元素的 i 和 j 互换。
3. 重新排列三元组表中的元素顺序。

**简单实现思路：不断遍历存储矩阵的三元组表，每次都从中取出 j 最小的那一个元素（如果有多个，则按照他们原来在三元组中的次序依次取出），互换 i 和 j，然后存储到一个新的三元组表中**

![矩阵转置的第一个过程](http://c.biancheng.net/uploads/allimg/190426/1P24161c-2.gif)

![矩阵转置的第二个过程](http://c.biancheng.net/uploads/allimg/190426/1P2416144-3.gif)

该算法的时间复杂度为 $O(n^2)$

[稀疏矩阵的转置算法](http://c.biancheng.net/view/3374.html)

# 树

## 树的常用定理

度
: 一个结点含有的子结点的个数
: 树中的度指的是结点拥有的子树数量

1. 所有结点的度数之和是边数的 2 倍（这里的度是指一般的度）
2. 树中的边数等于结点数减 1
3. 正则二叉树叶子数比度为 2 的结点数多一个 ($n_0=n_2+1$)

## 二叉树

### 二叉树的遍历

[二叉树先序遍历](http://c.biancheng.net/view/3388.html)

确定了二叉树的遍历方式，就相当于确定了一个将二叉树转换为线性表的规则。

### 通过前序和中序推导树

> 写之前把前序和中序抄下来，先序每分析一个结点，就划掉一个，并在中序中把这个结点变成墙（很粗的分割线）。当其左右结点确认下来后，将其涂黑。

1. 确定根结点（前序的第一个结点，后序的最后一个结点），根据根结点将中序分割成左子树和右子树。画出根结点和左右分支。
2. 将左子树和右子树看成新的树，重复第一步。

------

**例：前序：ABCDEF，中序：CBAEDF**

A 是根结点，将中序分为：[CB]A[EDF]，[CB] 是左子树，[EDF] 是右子树。画出根结点和左右两个分支。

左分支分析 CB，前序是 BC，B 是根结点，将 CB 分为 [C]B，[C] 是左子树。

右分支分析 EDF，前序是 DEF，D 是根结点，将 EDF 分为 [E]D[F]，[E] 是左子树，[F] 是右子树。

------

> 任何二叉树都可由中序序列和另一个序列唯一确定

### 线索二叉树

```cpp
typedef enum {Link, Thread} PointerTag; //指示指针域存储的是孩子还是前驱后继的枚举

class BiThrNode {
  TElemType data; //数据域
  BiThrNode *lchild, *rchild; //左、右孩子指针域
  PointerTag Ltag, Rtag; //标志域
} BiThrNode, *BiThrTree;
```

#### 对二叉树进行线索化

```c
//中序对二叉树进行线索化
void InThreading(BiThrTree node) {
  static BiThrNode *pre = NULL; //上一次访问的结点，即前驱
  if (node) { //如果当前结点存在
    InThreading(node->lchild); //递归左子树进行线索化
    //如果当前结点没有左孩子，写入前驱
    if (!node->lchild) {
      node->Ltag = Thread;
      node->lchild = pre;
    }
    //如果前驱没有右孩子，写入后继
    if (pre && !pre->rchild) {
      pre->Rtag = Thread;
      pre->rchild = node;
    }
    pre = node; //更新前驱
    InThreading(node->rchild); //递归右子树进行线索化
  }
}
```

> 在两条递归语句中间的语句相当于遍历二叉树中的访问操作。如果把它放到两条递归语句前面，就变成前序线索二叉树。

#### 遍历线索二叉树

**中序二叉树可以分成左右两部分来看待：左子树和自己属于同一分支，右子树属于另一个分支。遍历时，找到当前分支最左下的结点，然后依次访问其后继，直到出现右子树，访问右子树，然后重复循环。**

**每个转折，分叉都看成一个树**

![图片](../assets/IMG_26.png)

![图片](../assets/IMG_27.png)

```c
//中序遍历线索二叉树
void InOrderThraverse_Thr(BiThrTree node) {
  while (node) {
    while (node->Ltag == Link) { //移步到最左下的结点
      node = node->lchild;
    }
    printf("%c ", node->data);  //访问结点
    //如果结点存储了后继，就直接访问后继
    while (node->Rtag == Thread && node->rchild != NULL) {
      node = node->rchild;
      printf("%c ", node->data);
    }
    //如果没有后继，说明有右孩子。移步到右孩子，重复循环。
    node = node->rchild;
  }
}
```

[线索二叉树](http://c.biancheng.net/view/vip_3391.html)

### 双向线索二叉树

#### 线索化

在线索二叉树的基础上，添加一个头结点，其左孩子指向二叉树的树根，右孩子指向最后一个结点。这样就可以反向遍历（中序）二叉树：

![双向线索二叉链表](http://c.biancheng.net/uploads/allimg/190427/09523Gb6-0.png)

```cpp
//建立双向线索链表
void InOrderThread_Head(BiThrTree *head, BiThrTree tree) {
  //初始化头结点
  (*head) = (BiThrTree) malloc(sizeof(BiThrNode));
  if ((*head) == NULL) {
    printf("申请内存失败");
    return;
  }
  (*head)->Ltag = Link;
  (*head)->Rtag = Link;
  //如果树本身是空树
  if (!tree) {
    (*head)->lchild = *head;
    (*head)->rchild = *head;
  } else {
    pre = *head; //前驱
    (*head)->lchild = tree; //头结点的左孩子指向树根
    pre = InThreading(tree, pre); //稍作修改的线索化二叉树的函数，从外部接收 pre 参数，并返回最后的 pre 参数。
    pre->rchild = *head;
    pre->Rtag = Thread;
    (*head)->rchild = pre;
  }
}
```

#### 正向遍历

和普通线索二叉树的区别是，while 循环判断的条件不是 `while (node)`，而是 `while (node != head)` 以及 `while (node->rchild != head)`

```c
//中序正向遍历双向线索二叉树
void InOrderThraverse_Thr(BiThrTree head) {
  BiThrTree node = head->lchild;
  while (node != head) {
    while (node->Ltag == Link) {
      node = node->lchild;
    }
    printf("%c ", p->data);
    while (node->Rtag == Thread && node->rchild != head) {
      node = node->rchild;
      printf("%c ", node->data);
    }
    node = node->rchild;
  }
}
```

#### 逆向遍历

逆向遍历只要把右孩子当作左孩子，左孩子当作右孩子，然后正常遍历即可。

这时相当于右子树和自己是同一分支，左子树是另一分支。

![图片](../assets/IMG_25.png)


```c
//中序逆向遍历线索二叉树
void InOrderThraverse_Thr(BiThrTree head) {
  BiThrTree node = head->rchild;
  while (node != head) {
    while (node->Rtag == Link) //移步到最右下的结点
    {
      node = node->rchild;
    }
    printf("%c", node->data); //访问结点
    //如果结点存储了前驱，就直接访问前驱
    while (node->Ltag == Thread && node->lchild != h) {
      node = node->lchild;
      printf("%c", node->data);
    }
    //如果没有前驱，说明有左孩子。移步到左孩子，重复循环
    node = node->lchild;
  }
}
```

[双向线索二叉树](http://c.biancheng.net/view/vip_3393.html)

## 树

树与二叉树的区别：

1. 二叉树是有序树。
2. 树的度指树中最大的度。因此度为 2 的树不能是空树。而二叉树可以是空树。

### 树的孩子兄弟表示法

其实和二叉树的存储结构是一样的，这样就将树转化为了二叉树。树转化为二叉树后，原来的兄弟节点变成了右子树。于是树就变成了一个由左分支串起来的一堆兄弟节点子树。

树转化为二叉树时，最左分支不变，其余的所有分支都连到最左结点上。

二叉树还原成树时，左分支不用变，右分支断开，连到自己的父结点上。

![图片](../assets/IMG_28.png)￼

![pic](https://img-blog.csdnimg.cn/20200524112124510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R5Z21j,size_16,color_FFFFFF,t_70)

```c
class TreeNode {
  ElemType val;
  TreeNode *nextSon, *nextBro;
}
```

### 树的遍历

先根遍历：先访问根结点，再按照从左到右的顺序依次访问每一棵子树。**先根遍历对应二叉树的先序遍历。**

后根遍历：先从左到右依次访问每一棵子树，再访问根结点。**后根遍历对应二叉树的中序遍历。**

## 森林

### 森林转化为二叉树

前面说过，中序访问的二叉树可以分成左右两个部分，左子树和自己是同一分支，右子树是另一分支（相当于右分支串了一堆左子树）。因此，可以把第一棵树作为第一个左子树，第二棵树作为第二个左子树，...

￼￼![图片](../assets/IMG_29.png)

具体操作：

1. 将森林中所有树转化为二叉树
2. 将第一课树的树根作为整个森林的树根，其他树的树根看作第一棵树根结点的兄弟节点，采用孩子兄弟法将所有树进行连接。

森林转化为二叉树后，其前序遍历和中序遍历访问结点的顺序是不变的。

### 森林的遍历

#### 先序遍历

> 相当于二叉树的先序遍历

1. 访问森林中第一棵树的根结点
2. 先根遍历根结点的子树
3. 去掉第一棵树，重复

#### 中序遍历

> 相当于二叉树的中序遍历

1. 中序遍历第一棵树的根结点的子树
2. 访问第一棵树的根结点
3. 去掉第一棵树，重复

### 树与等价问题

$x$ 关于 $R$ 的等价类
: $[x]_R=\{y\mid y\in S\land xRy\}$
: $x$ 称为等价类 $[x]$ 的表示元素
: $R$ 的不同等价类的个数叫做 $R$ 的秩

------

**$R$ 是自然数集合 $\N$ 上的模 3 等价关系 $\equiv_3$，试给出 $\equiv_3$ 所确定的等价类。**

$\begin{matrix}
[0]_3=\{0, 3, 6, \ldots\}\\
[1]_3=\{1, 4, 7, \ldots\}\\
[2]_3=\{2, 5, 8, \ldots\}
\end{matrix}$

------

#### 划分等价类

1. 将每个元素看成单个集合
2. 如果有等价关系偶对 $(x,y)$，如果两个元素来自不同集合，则将两个集合合并
3. 剩下的所有非空集合就是等价类

用森林表示一个划分 $S=S_1\cup S_2\cup\cdots\cup S_n$

一棵树就是一个等价类。树根是这个等价类的代表元素。

集合的合并：一个根指向另一个根

```cpp
class Node {
  int val;
  Node *parent;
};

class MFSet {
  int n;
  Node nodes[MAXSIZE];
};
```

改进：

1. 每次归并让深度少的指向深度多的
2. Find 时压缩路径

#### 哈夫曼树（最优二叉树）

二叉树的带权路径长度是二叉树中所有叶子的带权路径长度之和。

> 把二叉树中除树根外所有非叶子结点的权加起来就是二叉树的带权路径长度

**构造方法**

将所有叶子按权值升序排列。每次找到两个权值最小的两片叶子，将它们合并起来，不断重复。

**哈夫曼编码**

如果对每个字符设计长度不同的编码，且让电文中出现次数较多的字符采用较短的编码，则可以减短电文的总长。利用前缀编码解决译码二义性的问题。

前缀编码
: 长度不等的编码，任一个编码都不是另一个编码的前缀

##### 利用二叉树设计二进制前缀编码

将左分支当作 0，右分支当作 1，以字符的出现频率作为权值构造最优二叉树。

译码时根据编码指引探索二叉树（0 往左走，1 往右走），找到对应的字符叶子。

##### 实现

对于给定的叶子个数，其正则二叉树的结点个数是已知的 ($n=2n_0-1$)，因此可以用线性结构存储哈夫曼二叉树。

构造一个长度为 2n - 1 的数组，前 n 个用于存储叶子，后 n - 1 个用于存储父结点。

```c
typedef struct {
  unsigned weight;
  unsigned parent
  unsigned lchild, rchild;
} HTNoode, *HuffmanTree;

typedef char **HuffmanCode; //由于每个字符的编码长度不同，因此应该用动态数组存储哈夫曼编码。HuffmanCode 是指向存储所有字符的哈夫曼编码的二维数组的指针
```

分配哈夫曼编码分为两步：

1. 构造哈夫曼树
2. 从叶子到根遍历哈夫曼树，确定每个字符的哈夫曼编码

> 也可以从根到叶子遍历二叉树

##### 确定哈夫曼编码

```c
void HuffmanCoding(HuffmanTree HT, HuffmanCode *HC, int n) { //HT 为哈夫曼树（数组），HC 为存储所有哈夫曼编码的字符串数组，n 为结点的个数
  *HC = (HuffmanCode)malloc((n + 1) * sizeof(char*)); //HC[0] 不用，因此申请 n + 1 个空间
  char *temp = (char*)malloc(n * sizeof(char)); //临时存放结点哈夫曼编码的字符串
  temp[n - 1] = '\0'; //每次从临时字符串倒数第二个位置开始反向填写哈夫曼编码
  for (int i = 1; i <= n; ++i) {
    //从叶子结点出发，得到的哈夫曼编码是逆序的，需要在字符串数组中逆序存放
    int flag = n - 1; //上一个编码填在临时数组的哪里
    int cur = i; //当前结点在数组中的位置
    int parent = HT[i].parent; //父结点在数组中的位置
    // 一直寻找到根结点
    while (parent != 0) {
      // 如果该结点是左孩子则编码为 0，否则编码为 1
      if (HT[parent].left == cur)
        temp[--flag] = '0';
      else
        temp[--flag] = '1';
      //更新父子结点
      cur = parent;
      parent = HT[parent].parent;
    }
    //分配哈夫曼编码
    (*HC)[i] = (char*)malloc((n - flag) * sizeof(char));
    strcpy((*HC)[i], &temp[start]);
  }
  free(temp);
}
```

[哈夫曼编码](http://c.biancheng.net/view/vip_3399.html)

# 图

图
: 无向图的边数不超过 $\dfrac{n(n-1)}{2}$
: 有向图的边数不超过 $n(n-1)$

> 网就是边带权的图

## 图的邻接矩阵表示

若存在边 [i, j]，则 a[i, j] 设为 1，否则设为 0.

在网中，a[i, j] 的值是边 [i, j] 的权。若边不存在，则 a[i, j] 设为 $\infty$

第 i 行表示 v~i~ 的出度，第 j 列表示 v~j~ 的入度。

## 图的邻接表存储

结点用数组存储，每个结点都有一个存储其所有边的链表。

```cpp
//表头
class Node {
  string  name; //存储结点的名称
  Arc    *firstArc; //存储
};

//表结点
class Arc {
  Node *adjVex//邻接的结点指针
  int   info; //边的权
  Arc  *nextArc; //结点的下一条边
};

//邻接表
class ALGraph {
  Node[MAX_VERTEX_NUM] vertices; //结点数组
  int vexNum, arcNum;
  int kind;
};
```

> 逆邻接表：存储入弧

## 十字链表

将有向图的邻接表和逆邻接表结合在一起就得到了十字链表

```cpp
class Node {
  string  name;
  Arc    *firstIn;
  Arc    *firstOut;
};

class Arc {
  Node *from;
  Node *to;
  int   info;
  Arc  *nextIn;
  Arc  *nextOut;
}
```

## 邻接多重表

类似十字链表

```cpp
class Node {
  string name;
  Arc    *firstArc;
};

class Arc {
  bool  mark;
  int   info;
  Node *iNode;
  Node *jNode;
  Arc  *iArc;
  Arc  *jArc;
}
```

## 图的遍历

邻接表存储方式的时间复杂度：$O(n+e)$

邻接矩阵存储方式的时间复杂度：$O(n^2)$

两种遍历方法分别生成两种生成树。

### DFS

> 类似二叉树的先序遍历

1. 从顶点 v 出发，访问 v
2. 把 v 的邻接点作为新的 v
3. 重复 1，2

> stack

```c
while (还有未访问的顶点 v)
if (v 未访问) {
  访问 v;
}
if (v 有未访问的邻接点) {
  push(v);
  v = v 的邻接点;
} else {
  v = top();
  pop();
}
```

图可分为三部分：

- 基结点
- 第一个邻接点组成的子图
- 其他邻接点组成的子图

先访问自己，然后访问第一个邻接点的子图，然后其他结点的子图。

访问完成后，扫描所有结点，若某个结点未访问过，则以它为基结点，再次执行 DFS。

### BFS

> 类似树的层次遍历

1. 从顶点 v 出发，访问 v
2. 访问 v 的所有邻接点
3. 分别访问所有邻接点的邻接点
4. 重复 3

> queue

```c
while (
```

## 图的连通性

